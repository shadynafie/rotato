generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// Note: SQLite doesn't support enums, so we use String with validation in code
// ClinicianRole: "consultant" | "registrar"
// RegistrarGrade: "junior" | "senior"
// Session: "AM" | "PM" | "FULL"
// RotaSource: "jobplan" | "oncall" | "manual" | "leave" | "rest"
// LeaveType: "annual" | "study" | "sick" | "professional"
// CoverageReason: "leave" | "oncall_conflict" | "manual"
// CoverageStatus: "pending" | "assigned" | "cancelled"
// CoverageType: "registrar" | "consultant" (who needs to cover: registrar covers registrar duty, consultant covers consultant duty)
// NotificationChannel: "email" | "whatsapp_stub"
// NotificationType: "change" | "digest" | "test"
// NotificationStatus: "pending" | "sent" | "failed"

model User {
  id           Int      @id @default(autoincrement())
  email        String   @unique
  passwordHash String
  role         String   @default("admin")
  createdAt    DateTime @default(now())
  createdRota  RotaEntry[] @relation("createdByUser")
  updatedRota  RotaEntry[] @relation("updatedByUser")
  auditLogs    AuditLog[]
}

model Clinician {
  id              Int           @id @default(autoincrement())
  name            String
  role            String        // "consultant" | "registrar"
  grade           String?       // null for consultants, "junior" | "senior" for registrars
  email           String?
  notifyEmail     Boolean       @default(true)
  notifyWhatsapp  Boolean       @default(false)
  active          Boolean       @default(true)
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  jobPlanWeeks    JobPlanWeek[]
  oncallSlots     OncallCycle[]  // DEPRECATED: old on-call system
  slotAssignments SlotAssignment[]  // NEW: slot-based on-call system
  rotaEntries     RotaEntry[]
  leaves          Leave[]
  notifications   Notification[]
  coverageRequestsAsConsultant CoverageRequest[] @relation("CoverageConsultant")
  coverageAssignmentsAsRegistrar CoverageRequest[] @relation("CoverageRegistrar")
  coverageRequestsAsAbsent CoverageRequest[] @relation("CoverageAbsent")
  coverageRequestsAsAbsentConsultant CoverageRequest[] @relation("CoverageAbsentConsultant")
  coverageAssignmentsAsConsultant CoverageRequest[] @relation("CoverageAssignedConsultant")
}

model Duty {
  id               Int           @id @default(autoincrement())
  name             String
  color            String?
  requiresCoverage Boolean       @default(true)
  active           Boolean       @default(true)
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt
  jobPlanAm         JobPlanWeek[] @relation("JobPlanWeek_amDuty")
  jobPlanPm         JobPlanWeek[] @relation("JobPlanWeek_pmDuty")
  rotaEntries       RotaEntry[]
  coverageRequests  CoverageRequest[]
}

model JobPlanWeek {
  id          Int      @id @default(autoincrement())
  clinician   Clinician @relation(fields: [clinicianId], references: [id])
  clinicianId Int
  weekNo      Int       // 1-5 (week of the month)
  dayOfWeek   Int       // 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday
  amDuty      Duty?    @relation("JobPlanWeek_amDuty", fields: [amDutyId], references: [id])
  amDutyId    Int?
  pmDuty      Duty?    @relation("JobPlanWeek_pmDuty", fields: [pmDutyId], references: [id])
  pmDutyId    Int?
  // For registrars: which consultant they support for this duty (null = independent duty)
  amSupportingClinicianId Int?
  pmSupportingClinicianId Int?
  notes       String?

  @@unique([clinicianId, weekNo, dayOfWeek])
}

// DEPRECATED: Keep during migration, remove after slot-based system is complete
model OncallCycle {
  id           Int      @id @default(autoincrement())
  role         String   // "consultant" | "registrar"
  cycleLength  Int
  position     Int
  clinician    Clinician @relation(fields: [clinicianId], references: [id])
  clinicianId  Int
  startDate    DateTime?

  @@unique([role, position])
}

// ============================================
// NEW SLOT-BASED ON-CALL SYSTEM
// ============================================

// Abstract on-call positions (e.g., "Registrar 01", "Consultant 03")
model OnCallSlot {
  id          Int               @id @default(autoincrement())
  name        String            // "Registrar 01", "Consultant 03"
  role        String            // "consultant" | "registrar"
  position    Int               // 1-7, for ordering
  active      Boolean           @default(true)
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt

  assignments SlotAssignment[]
  patterns    OnCallPattern[]

  @@unique([role, position])
}

// Maps clinicians to slots with effective date ranges
model SlotAssignment {
  id            Int        @id @default(autoincrement())
  slot          OnCallSlot @relation(fields: [slotId], references: [id], onDelete: Cascade)
  slotId        Int
  clinician     Clinician  @relation(fields: [clinicianId], references: [id])
  clinicianId   Int
  effectiveFrom DateTime
  effectiveTo   DateTime?  // null = current/ongoing assignment
  createdAt     DateTime   @default(now())
  createdBy     Int?       // For audit trail

  @@index([slotId, effectiveFrom])
  @@index([clinicianId])
}

// Role-level configuration for on-call cycles
model OnCallConfig {
  id          Int      @id @default(autoincrement())
  role        String   @unique  // "consultant" | "registrar"
  cycleLength Int      // 7 (weeks for consultants) or 49 (days for registrars)
  startDate   DateTime // Anchor date for cycle calculation
  unitType    String   // "week" | "day"
  updatedAt   DateTime @updatedAt
}

// Explicit pattern for registrar on-call (49 days)
// Consultants use implicit pattern: week N = slot with position N
model OnCallPattern {
  id          Int        @id @default(autoincrement())
  role        String     // "registrar" only
  dayOfCycle  Int        // 1-49
  slot        OnCallSlot @relation(fields: [slotId], references: [id], onDelete: Cascade)
  slotId      Int

  @@unique([role, dayOfCycle])
  @@index([role])
}

model RotaEntry {
  id          Int        @id @default(autoincrement())
  date        DateTime
  clinician   Clinician  @relation(fields: [clinicianId], references: [id])
  clinicianId Int
  session     String     // "AM" | "PM" | "FULL"
  duty        Duty?      @relation(fields: [dutyId], references: [id])
  dutyId      Int?
  isOncall    Boolean    @default(false)
  source      String     // "jobplan" | "oncall" | "manual" | "leave"
  note        String?
  // For registrar manual entries: which consultant they are supporting
  supportingClinicianId Int?
  createdBy   Int?
  updatedBy   Int?
  createdByUser User?    @relation("createdByUser", fields: [createdBy], references: [id])
  updatedByUser User?    @relation("updatedByUser", fields: [updatedBy], references: [id])
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  @@unique([date, clinicianId, session])
  @@index([date])
  @@index([date, isOncall])
}

model Leave {
  id          Int        @id @default(autoincrement())
  clinician   Clinician  @relation(fields: [clinicianId], references: [id])
  clinicianId Int
  date        DateTime
  session     String     // "AM" | "PM" | "FULL"
  type        String     // "annual" | "study" | "sick" | "professional"
  note        String?
  createdBy   Int?
  createdAt   DateTime   @default(now())

  @@unique([clinicianId, date, session])
  @@index([date])
}

model Notification {
  id          Int       @id @default(autoincrement())
  clinician   Clinician? @relation(fields: [clinicianId], references: [id])
  clinicianId Int?
  channel     String    // "email" | "whatsapp_stub"
  type        String    // "change" | "digest" | "test"
  payload     String?   // JSON stored as string
  status      String    @default("pending") // "pending" | "sent" | "failed"
  error       String?
  sentAt      DateTime?
  createdAt   DateTime  @default(now())
}

model AuditLog {
  id          Int      @id @default(autoincrement())
  actor       User?    @relation(fields: [actorUserId], references: [id])
  actorUserId Int?
  action      String
  entity      String
  entityId    Int?
  before      String?  // JSON stored as string
  after       String?  // JSON stored as string
  createdAt   DateTime @default(now())

  @@index([entity, entityId])
}

model ShareToken {
  id          Int      @id @default(autoincrement())
  token       String   @unique
  description String?
  active      Boolean  @default(true)
  createdAt   DateTime @default(now())
  lastUsedAt  DateTime?
}

model CoverageRequest {
  id                  Int        @id @default(autoincrement())
  date                DateTime
  session             String     // "AM" | "PM"
  type                String     @default("registrar") // "registrar" | "consultant" - who needs to cover
  consultantId        Int?       // For registrar coverage: the consultant being supported
  consultant          Clinician? @relation("CoverageConsultant", fields: [consultantId], references: [id])
  dutyId              Int
  duty                Duty       @relation(fields: [dutyId], references: [id])
  reason              String     // "leave" | "oncall_conflict" | "manual"
  status              String     @default("pending") // "pending" | "assigned" | "cancelled"
  // For registrar coverage: the absent registrar
  absentRegistrarId   Int?
  absentRegistrar     Clinician? @relation("CoverageAbsent", fields: [absentRegistrarId], references: [id])
  // For consultant coverage: the absent consultant (on-call or on leave)
  absentConsultantId  Int?
  absentConsultant    Clinician? @relation("CoverageAbsentConsultant", fields: [absentConsultantId], references: [id])
  // Assignment fields - registrar or consultant depending on type
  assignedRegistrarId Int?
  assignedRegistrar   Clinician? @relation("CoverageRegistrar", fields: [assignedRegistrarId], references: [id])
  assignedConsultantId Int?
  assignedConsultant  Clinician? @relation("CoverageAssignedConsultant", fields: [assignedConsultantId], references: [id])
  assignedBy          Int?
  assignedAt          DateTime?
  note                String?
  createdAt           DateTime   @default(now())
  updatedAt           DateTime   @updatedAt

  @@unique([date, session, dutyId, absentRegistrarId])
  @@unique([date, session, dutyId, absentConsultantId])
  @@index([date])
  @@index([status])
  @@index([type])
  @@index([absentRegistrarId])
  @@index([absentConsultantId])
  @@index([consultantId])
}
